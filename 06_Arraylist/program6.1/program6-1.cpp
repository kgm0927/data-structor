#include <stdio.h>
#include <stdlib.h>



//
//			06 연결 리스트 1
// 
// 
// 
//		6.1 리스트 추상 데이터 삽입
// 
// 
//		리스트의 소개
// 
// 리스트(list)는 우리들이 자료를 정리하는 방법 중의 하나이다. 우리는 일상 생활에서 많은 리스트를 사용하는데, 예를 들어
// 오늘 해야 할일이나 쇼핑해야할 항목들을 리스트로 관리한다. 다음과 같은 것들이 전형적인 리스트이다.
// 
// 리스트에는 항목들이 차례대로 저장되어 있다. 리스트의 항목들은 순서 또는 위치를 가진다. 앞에서 살펴본 스택과 큐도 넓게 보면
// 리스트의 일종이다. 리스트는 기호로 다음과 같이 표현한다. 리스트는 집합하고 다르다. 집합은 각 항목 간에 순서의 개념이 없다.
// 
// 
//		
//			L=(item_0,item_1,item_2, ... , item_(n-1))
// 
// 
//		다음과 같은 기본적인 연산들을 생각할 수 있다.
// 
// 
//		* 리스트에 새로운 항목을 추가한다 (삽입 연산).
//		* 리스트에서 항목을 삭제한다. (삭제 한다.).
//		* 리스트에서 특정한 항목을 찾는다.(탐색 연산).
// 
// 
// 
// 
//				리스트 ADT
// 
// 다음은 리스트를 추상 데이터 타입으로 정의한 것이다. 앞에서 생각해본 연산들에 이름을 붙이고 설명한 것이다.
// 
// -------------------------------------------------------------------------------------------------------------------------------------
//		ADT 6.1 리스트
// -------------------------------------------------------------------------------------------------------------------------------------
//		* 객체: n개의 element 형으로 구성된 순서 있는 모임
//		* 연산:
//				insert(list,pos,item) ::= pos 위치에 요소를 추가한다.
//				insert_last(list,item) ::= 맨 끝에 요소를 추가한다.
//				insert_first(list,item) ::= 맨 처음에 요소를 추가한다.
//				delete(list,pos) ::= pos 위치의 요소를 제거한다.
//				clear(list) ::= 리스트의 모든 요소를 제거한다.
//				get_entry(list,pos) ::= pos 위치의 요소를 반환한다.
//				get_length(list) ::= 리스트의 길이를 구한다.
//				is_empty(list) ::= 리스트가 비었는지 검사한다.
//				is_full(list) ::= 리스트가 꽉찼는지를 검사한다.
//				print_list(list) ::= 리스트의 모든 요소를 표시한다.
// 
// -------------------------------------------------------------------------------------------------------------------------------------
// 
// 
//			리스트의 구현
// 
// 이제부터는 리스트 ADT를 어떻게 구현할 것인지를 생각해보자. 리스트는 배열과 연결 리스트를
// 이용하여 구현할 수 있다. 배열을 이용하면 리스트 ADT를 간단하게 구현할 수 있다.
// 
// 
// 배열을 사용하여 리스트를 구현하면 장점과 단점이 존재한다. 장점은 구현이 간단하여 속도가 빠르다는 것이다. 단점으로는 리스트의 
// 크기가 고정되는다는 것을 들을 수 있다. 즉 배열의 특성상 동적으로 크기를 늘리거나 줄이는 것이 힘들다. 따라서 데이터를 추가하고
// 싶은데 더 이상 남는 공간이 없다면 문제가 발생한다.
// 
// 연결 리스트는 크기가 제한되지 않고, 중간에서 쉽게 삽입하거나 삭제할 수 있는 유연한 리스트를 구현할 수 있다. 하지만 연결 리스트도 단점이 있는데,
// 구현이 복잡하고, 임의의 항목을 추출하려고 할 때는 배열을 사용하는 것 보다 시간이 많이 걸린다.
//				
// 
// 
// 
// 
// 
// 
// 
// 
//		6.2 배열로 구현된 리스트
// 
// 
// 배열로 연결된 리스트를 구현해보자. 배열을 이용하여 리스트를 구현하면 순차적인 메모리 공간으로 할당되므로, 이것을 리스트의 순차적 표현
// (sequential representation)라고도 한다.
// 
// 
// 배열을 이용하면 리스트의 항목을 아주 자연스럽게 저장할 수 있다. 좀 더 자세한 내용은 다음의 가상 실습 소프트웨어를 이용해서 살펴보자.
//




//
//			리스트의 정의
// 
// 
// 배열로 리스트를 구현하기 위하여 배열과 항목의 개수를 구조체로 묶어서 ArrayListType이라는
// 새로운 타입을 정의하도록 하자.
//

#define MAX_LIST_SIZE 100

typedef int element;

typedef struct {
	element array[MAX_LIST_SIZE];
	int size;
}ArrayListType;

//
//			기초 연산
// 
// 리스트의 연산들을 함수로 구현해보자. 모든 연산은 구조체 포인터를 받는다. 구조체
// 포인터를 받아야 하는 이유는 함수 안에서 구조체를 변경할 필요도 있기 때문이다.
// 포인터를 사용하지 않으면 구조체의 복사본이 전달되어서 원본 구조체를 변경할 수 
// 없다. 일단 쉽게 구현할 수 있는 연산부터 구현해보자.
// 
//

void error(const char* message) {
	fprintf(stderr, "%s\n", message);
	exit(1);
}

void init(ArrayListType* L) {
	L->size = 0;
}

int is_empty(ArrayListType* L) {
	return L->size == 0;
}

int is_full(ArrayListType *L) {
	return L->size == MAX_LIST_SIZE;
}

element get_entry(ArrayListType* L, int pos) {
	if (pos<0||pos>=L->size)
	{
		error("위치 오류");
	}
	return L->array[pos];
}

void print_list(ArrayListType *L) {
	int i;
	for ( i = 0; i < L->size; i++)
	{
		printf("%d->", L->array[i]);
	}
	printf("\n");
}

//
//		항목 추가 연산
// 
// 이제 리스트의 맨 끝에 항목을 추가하는 insert_last() 함수를 구현해보자.
// 
//
void insert_last(ArrayListType* L, element item) {
	if (L->size>=MAX_LIST_SIZE)
	{
		error("리스트 오버플로우");

	}
	L->array[L->size++] = item;
}
//
// insert_last() 함수에서는 리스트에 빈공간이 없으면 오류를 발생시킨다.
// 
// 이제 리스트의 pos 위치에 새로운 항목을 추가하려면 어떻게 해야 할까? 이런 경우에는 pos번째부터
// 마지막 항목까지 한 칸식 오른쪽으로 이동하여 빈자리를 만든 후에, 새로운 항목을 pos 위치에 저장하여야 한다.
// 
// 
// 
//

//
// 임의의 위치에 삽입하는 insert() 함수를 구현해보자.
//
void insert(ArrayListType* L, int pos, element item) {
	if (!is_full(L)&&(pos>=0)&&(pos<=L->size))
	{
		for (int i = (L->size-1); i >=pos; i--)
		{
			L->array[i + 1] = L->array[i];
		}
		L->array[pos] = item;
		L->size++;

	}
}



//
//			항목 삭제 연산
// 
// pos 위치에 항목을 삭제하는 delete(list,pos)를 구현해보자. 이때도 마찬가지로 삭제한 후에 array[pos+1]부터 array[size-1]까지를 한 칸씩 앞으로 이동하여야 한다.
//
element Delete(ArrayListType* L, int pos) {
	element item;

	if (pos < 0 || pos >= L->size)
		error("위치 오류");

		item = L->array[pos];

	for (int i = 0; i < (L->size-1); i++)
	{
		L->array[i] = L->array[i + 1];
	}
	L->size--;

	return item;

}

int main(void) {
	ArrayListType list;

	init(&list);

	insert(&list, 0, 10); print_list(&list);
	insert(&list, 0, 20); print_list(&list);
	insert(&list, 0, 30); print_list(&list);
	insert_last(&list, 40); print_list(&list);

	Delete(&list, 0);
	print_list(&list);

	return 0;
}
/*
*	실행결과
*	10->
	20->10->
	30->20->10->
	30->20->10->40->
	20->10->40->
* 
* 
*/


//
// 10이 리스트의 0 번재 위치에 추가된다. 이어서 20이 0번째 위치에 추가되므로 기존의 10은 뒤로 밀리게 된다.
// 30이 0번째 위치에 추가되면 "30->20->10"과 같이 저장된다. insert_last()를 호출하여 40을 맨 끝에 추가하면
// "30->20->10->40"이 된다. delete()를 호출하여서 0번째 항목을 삭제하면 "20->10->40"이 된다.
// 
// 
// 
//			실행시간 분석
// 
// 배열로 구현한 리스트의 시간 복잡도를 살펴보자. 임의의 항목에 접근하는 연산인 get_entry 연산은 인덱스를 이용하여
// 바로 접근할 수 있으므로 명백히 O(1)이다. 삽입이나 삭제 연산은 다른 항목들을 이동하는 경우가 많으므로 최악의 경우
// O(n)이 된다. 예를 들어서 리스트가 거의 차있고 새로운 항목을 맨 처음 삽입하는 경우가 그렇다. 하지만 리스트의 맨 끝에
// 삽입하는 경우는 O(1)이다.
// 
// 
//