#include <stdio.h>
#include <stdlib.h>


//			
// 
//			6.3 연결 리스트
// 
// 이번 절에서 동적으로 크기가 변할 수 있고 삭제나 삽입 시에 데이터를 이동할 필요가 없는 연결된
// 표현(linked representation)에 대하여 배운다. 연결된 표현은 널리 사용되어 추상 데이터 타입 "리스트"
// 의 구현에만 사용되는 것이 아니고 다른 여러 가지의 자료구조(트리, 그래프, 스택, 큐)등을 구현하는데도
// 많이 사용된다.
// 
// 데이터들은 메인 메모리상의 어디에나 흩어져서 존재할 수 있다. 이런 식으로 물리적으로 흩어져 있는 자료들을 서로
// 연결하여 하나로 묶는 방법을 연결 리스트(linked list)라고 한다. 상자를 연결하는 줄은 포인터(pointer)로 구현한다.
// 
// 
// 
// 연결리스트를 사용하면 어떤 장점이 있을까? 배열을 이용한 리스트에서 가장 문제가 되었던, 중간에 삽입하는 문제를 생각하여 보자.
// 연결 리스트에서는 앞뒤에 있는 데이터들을 이동할 필요가 없이 줄만 변경시켜주면 된다. 삭제시에도 마찬가지이다. 항목 C를 삭제하려고
// 하면 데이터들을 옮길 필요가 없이 그냥 데이터들을 연결하는 줄만 수정하면 된다.
// 
// 
// 하지만 배열에 비하여 상대적으로 구현이 어렵고 오류가 나기 쉬운 점이 단점이라 할 수 있겠다. 또 데이터뿐만 아니라 포인터도 저장하여야
// 하므로 메모리 공간을 많이 사용한다. 또 데이터 뿐만 아니라 포인터도 저장하여야 하므로 메모리 공간을 많이 사용한다. 또 i번째 데이터를
// 찾으려면 앞에서부터 순차적으로 접근하여야 한다.
// 
// 
// 
// 
// 
//			연결 리스트의 구조
// 
// 
// 연결 리스트는 노드(node)들의 집합이다. 노드들은 메모리의 어떤 위치에나 있을 수 있으며 다른 노드로 가기 위해서는 현재 노드가 가지고 있는
// 포인터를 이용하면 된다. 노드는 데이터 필드(datat field)와 링크 필드(link field)로 구성되어 있다.
// 
// 
// '데이터 필드'에는 우리가 저장하고 싶은 데이터가 들어간다. '링크 필드'에는 다른 노드를 가리키는 포인터가 저장된다.
// 
// 연결 리스트에서는 연결 리스트의 첫번째 노드를 알아야 만이 전체 노드에 접근할 수 있는데, 첫 번째 노드를 가리키고 있는 변수가 필요한데 
// 이것을 '헤드 포인터(head pointer)'라고 한다. 그리고 마지막 노드의 링크 필드는 NULL으로 설정되는데 이는 더 이상 연결된 노드가 없다는
// 것을 의미한다. 연결 리스트의 노드들은 필요할 때마다 malloc()을 이용하여 동적으로 생성된다.
// 
// 
// 
// 
//			연결 리스트의 종류
// 
// 
// 다음과 같은 3가지 종류의 연결 리스트가 있다.
// 
// 단순 연결 리스트(singly linked list): 하나의 방향으로만 연결되어 있는 연결 리스트. 체인(chain)이라고도 한다. 마지막 노드의 링크는 NULL값을 가진다.
// 
// 원형 연결 리스트(circular linked list): 단순 연결 리스트와 같으나 마지막 노드의 링크가 첫 번째 노드를 가리킨다.
// 
// 이중 연결 리스트(doubly linked list): 각 노드마다 2개의 링크가 존재한다. 하나의 링크는 앞에 있는 노드를 가리키고 또 하나의 링크는 뒤에 있는 노드를 가리킨다.
// 
// 
// 
// 
// 
// 
// 
// 
//			6.4 단순 연결 리스트
// 
// 
// 단순 연결 리스트에서는 노드들이 하나의 링크 필드를 가지며 이 링크 필드를 이용하여 모든 노드들이 연결되어 있다. 마지막 노드의 링크 필드 값은 NULL이 된다.
// 
// 
// * 노드는 어떻게 정의할 것인가?-> 자기 참조 구조체를 이용한다.
// * 노드는 어떻게 생성할 것인가?-> malloc()을 호출하여 동적 메모리로 생성한다.
// * 노드는 어떻게 삭제할 것인가?-> free()를 호출하여 동적 메모리를 해제한다.
// 



//			노드의 정의
// 
// 노드는 '자기 참조 구조체'를 이용하여 정의된다. '자기 참조 구조체'란 자기 자신을 참조하는 포인터를 포함하는 구조체이다.
// 구조체 안에서는 저장하는 data 필드와 포인터가 저장되어 있는 link 필드가 존재한다.
// data 필드는 element 타입의 데이터를 저장하고 있다. link 필드는 ListNode를 가리키는 포인터로 정의되며
// 다음 노드의 주소가 저장된다.
// 
// 
// 
//
typedef int element;

typedef struct ListNode {
	element data;
	struct ListNode* link;
}ListNode;
//
// 위의 코드에서 노드의 구조는 정의하였지만 아직 노드는 생성되지 않았음에 주의하여야 한다.
// 구조체 ListNode는 노드를 만들기 위한 설계도에 해당된다. ListNode를 가지고 실제 구조체를
// 생성하려면 구조체 변수를 생성하여야 한다.
//


void error(const char* message) {
	fprintf(stderr, "%s\n", message);
	exit(1);
}

//
//			삽입 연산 insert_first()
// 
// 단순 연결 리스트의 경우, 리스트의 처음이나 끝에 새로운 노드를 추가하는 경우가 많다. 여기서 리스트의 첫 번째 부분에
// 새로운 노드를 추가하는 함수 insert_first()를 작성해보자. 여기서 매개 변수 head는 헤드 포인터이고 value는 새롭게 
// 추가되는 데이터이다.
// 
//
ListNode* insert_first(ListNode* head, int value) {
	ListNode* p = (ListNode*)malloc(sizeof(ListNode));
	p->data = value;
	p->link = head;
	head = p;
	return head;
}
//
// head가 첫 번째 노드를 가리키기 대문에 리스트의 시작 부분에 노드를 추가하는 것은 비교적 쉽다. 새로운 노드 하나를 생성하고
// 새로운 노드의 link에 head 값을 저장한 후에, head를 변경하여 새로 만든 노드를 가리키도록 하면 된다. insert_first()은 변경된
// 헤드 포인터를 반환한다. 따라서 반환된 값을 헤드 포인터에 저장하여야 한다.
// 
// 
//


//
//			삽입연산 insert()
// 
// insert()는 가장 일반적인 경우로서 연결 리스트의 중간에 새로운 노드를 추가한다. 이때는 반드시 삽입되는 위치의 선행 노드를 알아야
// 삽입이 가능하다. 선행 노드를 pre가 가리키고 있다고 가정하자. 예를 들어서 아래 그림에서 "20"과 "40" 사이에 "30"을 삽입하여야 한다.
// 다음과 같은 절차가 필요하다.
// 
// 
//		알고리즘 
// ----------------------------------------------------------------------------------------------------------------------------------
// insert(head,pre,value);
// 1. p<-malloc()
// 2. p-> data <-value
// 3. p-> link <- pre->link
// 4. pre->link <-p
// 5. return head
// ----------------------------------------------------------------------------------------------------------------------------------
// 
// 
//
ListNode* insert(ListNode* head, ListNode* pre, element value) {
	ListNode* p = (ListNode*)malloc(sizeof(ListNode));
	p->data = value;			// (2)
	p->link = pre->link;		// (3)
	pre->link = p;				// (4)
	return head;
}



//		delete_first() 함수
// 
// 첫번째 노드를 삭제하는 함수 delete_first() 함수는 다음과 같은 원형을 가진다.
// 
// ListNode* delete_first(ListNode* head)
// 
// 알고리즘 6.3 연결 리스트 삭제1
// -------------------------------------------------------------------------------------------------------------------------------------
// delete_first(head):
// 1. removed<- head
// 2. head<- head->link
// 3. free(removed);
// 4. return head
// -------------------------------------------------------------------------------------------------------------------------------------

ListNode* delete_first(ListNode* head) {
	ListNode* removed;
	if (head == NULL) return NULL;
	removed = head;
	head = removed->link;
	free(removed);
	return head;
}

//
// 삭제 연산 delete()
// 
// 리스트의 중간에서 삭제하는 알고리즘을 살펴보자. 다음과 같은 단순 연결 리스트에서 노드 "30"을 삭제한다고 한다.
// 
// 알고리즘 6.4 연결 리스트 삭제2
// --------------------------------------------------------------------------------------------------------------------------------------
// delete(head,pre):
// 1. removed <- pre-> link
// 2. pre-> link <- removed-> link
// 3. free(removed)
// 4. return head
// --------------------------------------------------------------------------------------------------------------------------------------- 
// 
ListNode* Delete(ListNode* head, ListNode* pre) {
	ListNode* removed;
	removed = pre->link;
	pre->link = removed->link;
	free(removed);
	return head;
}



//
//		print_list() 함수
// 
// 우리는 연결 리스트의 노드를 방문하면서 노드를 대상으로 다양한 작업을 할 수 있다. 예를 들어서 노드를 방문하면서 노드의 데이터를 화면에
// 출력할 수 있다. 연결 리스트 안의모든 노드의 데이터를 출력하는 함수 print_list를 작성해보자. 노드의 링크값이 NULL이 아니면 계속 링크를
// 따라 가면서 노드를 방문한다. 링크값이 NULL이면 연결 리스트의 끝에 도달한 것이므로 반복을 중단한다. 방문 연산은 연결 리스트에서 가장
// 기본이 되는 연산이므로 그 개념을 확실하게 이해해야 한다. 
// 
// 
// 
//
void print_list(ListNode* head) {
	for (ListNode *p = head; p !=NULL;p=p->link)
	{
		printf("%d->", p->data);

	}
	printf("NULL \n");

}

int main(void) {

	//
	//		공백 리스트의 생성
	// 
	// 단순 연결 리스트는 헤드 포인터만 있으면 모든 노드를 찾을 수 있다. 따라서 다음과 같이 노드를 가리키는 포인터 head
	// 를 정의하면 하나의 단순 연결 리스트가 만들어졌다고 볼 수 있다. 현재는 노드가 없으므로 head의 값은 NULL이 된다.
	//
	ListNode* head = NULL;
	//
	// 어떤 리스트가 공백인지를 검사하려면 헤드 포인터가 NULL인지를 검사하면 된다.
	//


	for (int i = 0; i < 5; i++)
	{
		head = insert_first(head, i);
		print_list(head);
	}
	for (int i = 0; i < 5; i++)
	{
		head = delete_first(head);
		print_list(head);

	}
	return 0;
}