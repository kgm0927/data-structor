#include <stdio.h>
#include <stdlib.h>

typedef int element;

//
//			8.11 이진 탐색 트리
// 
// 
// 이진 탐색 트리(binary search tree)는 이진 트리 기반의 탐색을 위한 자료이다. 탐색(search)은 가장 중요한 컴퓨터 응용의 하나이다.
// 
// 
// 먼저 탐색에 관련된 용어를 살펴보자. 컴퓨터 프로그램에서 탐색은 레코드(record)의 집합에서 특정한 레코드를 찾는 작업을 의미한다.
// 레코드는 하나 이상의 필드(field)로 구성된다. 예를 들면 학생의 레코드는 이름, 주소, 주민등록번호 등의 필드를 포함할 수 있다. 일반적으로
// 레코드들의 집합을 테이블(table)이라고 한다. 레코드들은 보통 키(key)라고 불리는 하나의 필드에 의해 식별할 수 있다. 일반적인 경우 어떤 키는
// 다른 키와 중복되지 않는 고유한 값을 가지고 이러한 키를 사용하면 각각의 레코드들을 구별할 수 있을 것이다. 이러한 키를 주요키(primary key)라고
// 부르며 학생의 경우, 주민등록번호나 학번이 이에 해당된다. 탐색 작업을 할 때에는 이러한 키가 입력이 되어 특정한 키를 가진 레코드를 찾는다.
// 이진 탐색 트리는 이러한 탐색 작업을 효율적으로 하기 위한 자료 구조이다.
// 
// 
// 
//			이진 탐색 트리의 정의
// 
// 이진 탐색 트리란 이진 탐색 트리의 성질을 만족하는 이진트리를 말한다. 이진 탐색  트리의 정의는
// 다음과 같다.
// 
//			정의 8.2 이진탐색트리
//---------------------------------------------------------------------------------------------------- 
// * 모든 원소의 키는 유일한 키를 가진다.
// * 왼쪽 서브 트리 키들은 루트키보다 작다.
// * 오른쪽 서브 트리의 키들은 루트의 키보다 크다.
// * 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.
// ---------------------------------------------------------------------------------------------------
// 
// 
// 따라서 찾고자 하는 키값이 이진트리의 루트 노드의 킷값과 비교하여 루트 노드보다 작으면 원하는 키 값은 왼쪽 서브트리에
// 있고 루트 노드보다 크면 원하는 키값은 오른쪽 서브 트리에 있음을 쉽게 알 수 있다. 이러한 성질로 쉽게 탐색할 수 있다.
// 
// 
// ex)
//		key(왼쪽 서브트리)<=key(가운데)<=key(오른쪽 서브트리)
//


typedef struct TreeNode {
	element key;
	struct TreeNode* left, * right;
}TreeNode;




//
//			순환적인 탐색연산
// 
// 이진 탐색 트리에서 특정한 키값을 가진 노드를 찾기 위해서는 먼저 주어진 탐색키와 루트 노드 값을 비교한다. 비교한 결과에 따라, 다음
// 3가지로 나누어진다.
// 
//		* 비교한 결과가 같으면 탐색이 성공적으로 끝난다.
//		* 비교한 결과가, 주어진 키 값이 루트 노드의 키값보다 작으면, 탐색은 이 루트 노드의 왼쪽 자식을 기준으로 다시 시작한다.
//		* 비교한 결과가, 주어진 키 값이 루트 노드의 키값보다 크면 탐색은 이 루트 노드의 오른쪽 자식을 기준으로 다시 시작한다.
// 
// 
// 이것을 알고리즘으로 정리하면 다음과 같다.
// 
// 
//		알고리즘 8.9		이진 탐색 트리 탐색 알고리즘(순환적)
// -------------------------------------------------------------------------------------------------------------------------------------
//			search(root,key):
// 
//		if root=NULL
//			then return NULL;
//		
//		if key== KEY(root)
//			then return root;
//			else if key < KEY(root)
//				then return search(LEFT(root),k);
//				then return search(RIGHT(root),k);
// --------------------------------------------------------------------------------------------------------------------------------------
// 
// 
// 이진 탐색 트리에서 탐색을 구현하는 방법은 순환적인 방법과 반복적인 방법이 있다.
// 먼저 순환적인 함수이다.

TreeNode* search(TreeNode* node, int key) {

	if (node == NULL)return NULL;
	if (key == node->key) return node;

	else if (key < node->key)
		return search(node->left, key);
	else
		return search(node->right, key);
	
	
}

//
//			반복적인 탐색연산
// 
// 이진 탐색트리를 탐색하는 방법에는 반복적인 방법도 존재한다. 사실 효율성을 따지면 반복적인 함수가 훨씬 우수하다.
// 다음 프로그램 8.10은 반복적인 기법으로 탐색 연산을 구현한 것이다.
// 
// (search.h참고)
// 
// 반복적인 탐색 함수는 먼저 매개변수 node가 NULL이 아니면 반복을 계속한다. 반복 루프 안에서는 현재 node의 키 값이
// key와 같은지를 검사한다.
// 만약 같으면 탐색 성공이므로 현재 노드 포인터를 반환하고 끝낸다.만약 key가 현재 노드 키값보다 작으면 node 변수를 node의 
// 왼쪽자식을 가리키도록 변경한다. 또한 현재 노드 키값보다 크면 node 변수를 node의 오른쪽 자식을 가리키도록 변경한다.
// 이러한 반복은 node가 결국 단말노드까지 내려가서 NULL값이 될 때까지 계속된다. 만약 반복이 종료되었는데도 아직 함수가
// 리턴되지 않았다면 탐색이 실패한 것이므로 NULL를 반환한다. 
// 
// 여기서는 함수의 매개변수 node를 직접 사용하는데, 사실 매개변수는 원본 변수의 복사본이므로 변경하여도 원본 변수에는
// 별 영향이 없다.
// 
//			
// 
//


//
// 위에서 new_node() 함수는 다음과 같이 동적으로 메모리를 할당하여 새로운 노드를 생성하여 반환하는 유틸리티 함수이다.
// 
//
TreeNode* new_node(int item) {
	TreeNode* temp = (TreeNode*)malloc(sizeof(TreeNode));
	temp->key = item;
	temp->left = temp->right = NULL;
	return temp;
}


//
//		이진탐색트리에서 삽입연산
// 
// 이진 탐색 트리에 원소를 삽입하기 위해서는 먼저 탐색을 수행하는 것이 필요하다. 이유는 이진 탐색 트리에서는
// 같은 키 값을 갖는 노드가 없어야 하기 때문이고 또한 탐색에 실패한 위치가 바로 새로운 노드를 삽입하는 위치가
// 되기 때문이다.
// 
// 만약에 이진 탐색 트리에서 알고리즘에 따라서 9를 삽입한다고 할 때, 먼저 (a)와 같이 루트에서부터 9를 탐색해본다.
// 만약 탐색이 성공하면 이미 9가 트리 안에 있는 것이고, 키가 중복되므로 삽입이 불가능하다. 만약 트리가 안에
// 없다면 어디선가 탐색이 실패로 끝날것이다. '바로 실패로 끝난 위치가 9가 있어야 할 곳이다.'
// 따라서 탐색이 끝난 위치인 곳에 9를 넣으면 된다.
// 
// 
// 
// 다음에 루트노드가 root인 이진탐색트리에 새로운 노드 n을 삽입하는 알고리즘을 보여주고 있다. 새로운 노드는 항상
// 단말에 추가된다. 우리는 단말 노드를 발견할 때까지 루트에서 키를 검색하기 시작한다. 단말 노드가 발견되면 새로운
// 노드가 단말노드의 하위 노드로 추가된다.
// 
// 
// ----------------------------------------------------------------------------------------------------------------------------
//		insert(root,n):
//	
//		if KEY(n)==KEY(root)
//			then return;
// 
//		else if KEY(n)<KEY(root) then
//			if LEFT(root)==NULL
//				then LEFT(root)<-n;
//				else insert(LEFT(root),n);
// 
//		else
//			 if RIGHT(root)==NULL
//			 then RIGHT(root)<-n
//			 else insert(RIGHT(root),n);
// -----------------------------------------------------------------------------------------------------------------------------
// 
// 다음은 이진 탐색 트리에서의 삽입 연산을 C언어로 구현한 것이다. 매개변수 root는 이진 탐색 트리의 루트 노드를 가리킨다. 삽입 함수에서는
// 루트 노드 포인터가 변경되어야 하므로 변경된 루트 포인터를 반환하였다. key는 삽입할 탐색키값을 의미한다.
//

TreeNode* insert_node(TreeNode* node, int key) {

	// 트리가 공백이면 새로운 노드를 반환한다.
	if (node == NULL) return new_node(key);

	// 그렇지 않으면 순환적으로 트리를 내려간다.
	if (key < node->key)
		node->left = insert_node(node->left, key);
	else if (key > node->key)
		node->right = insert_node(node->right, key);


	//변경된 루트 포인터를 반환한다.

	return node;

}



//
// 
//			이진 탐색 트리에서 삭제 연산
// 
// 노드를 삭제하는 것은 이진탐색트리에서 가장 복잡한 연산이다. 먼저 노드를 삭제하기 위해서 먼저 노드를 탐색하여야 한다는 것은
// 삽입과 마찬가지이다. 
// 
// 우선 우리가 삭제하려고 하는 키값이 트리 어디에 있는지 알아야 하는데, 노드를 탐색하였으면 다음의 3가지 경우를 고려해야 한다.
// 
//		1. 삭제하려는 노드가 단말일 경우
//		2. 삭제하려는 노드가 하나의 왼쪽이나 오른쪽 서브 트리중 하나만 가지고 있는 경우
//		3. 삭제하려는 노드가 두개의 서브트리 모두 가지고 있는 경우
// 
// 
// 세번째가 가장 어렵다.
// 
// 
// 
// * 첫 번째 경우: 삭제하려는 노드가 단말일 경우
// 
// 삭제하려는 노드가 단말 노드일 경우를 생각해본다. 이 경우에는 단말노드 아래에 더 이상의 노드가 없으므로
// 가장 쉽게 할 수 있다. 단말노드만 지우면 된다. 단말 노드를 지운다는 것은 단말노드의 부모노드를 찾아서
// 부모노드안의 링크필드를 NULL로 만들어서 연결을 끊으면 된다.
// 
// 
// 
// 
// * 두 번째 경우: 삭제하려는 노드가 하나의 서브트리만 가지고 있는 경우
// 
// 삭제되는 노드가 왼쪽이나 오른쪽 서브 트리 중 하나만 가지고 있는 경우에는 자기 노드는 삭제하고 서브트리는 자기
// 노드의 부모 노드에 붙여주면 된다.
// 
// 
// 
// 
// * 세 번째 경우: 삭제하려는 노드가 두개의 서브트리를 가지고 있는 경우
// 
// 
// 문제를 서브트리에 있는 어떤 노드를 삭제 노드 위치로 가져올 것이냐이다. 확실한 것은 왼쪽자식이나 오른쪽 자식을 그냥 가져오면
// 안 된다는 것이다. 그러면 어떤 노드를 가져와야만 다른 노드들을 변경시키지 않고 이진 탐색 트리의 조건을 만족할까?
// 
// 앞에서 비유하였듯이 서브 트리들을 정치 파벌이라고 생각하였을 경우, 삭제되는 노드와 가장 값이 비슷한 노드를 후계자로 선택하여야
// 다른 사람들과 마찰이 적을 것이다. 그래야만 가장 값이 가까운 노드를 이동하지 않아도 이진 탐색 트리가 그대로 유지된다. 
// 
// 이진 트리를 그려보면 왼쪽 서브트리에서 가장 큰 값이나 오른쪽 서브트리에서 가장 작은 값이 삭제되는 노드와 가장 가깝다는 것을 쉽게
// 알 수 있다. 왼쪽 서브트리에서 가장 큰 값은 왼쪽 서브트리의 가장 오른쪽에 있는 노드이며 오른쪽 서브트리에서 가장 작은 값은 오른쪽
// 서브트리에서 가장 왼쪽에 있는 노드가 된다.
// 
// 또한 이들 노드는 이진 탐색 트리를 중위순회하였을 경우, 각각 선행노드와 후속노드에 해당한다.
// 
// 그러면 이들 후계자 대상 노드 중에서 어떤 노드를 선택하여야 할까? 어느 것을 선택하여도 상관이 없지만, 오른쪽 서브트리에서 제일 작은
// 값을 후계자라고 할 때, 삭제되는 노드의 오른쪽 서브트리에서 가장 작은 값을 갖는 노드는 오른쪽 서브 트리에서 왼쪽 자식 링크를 타고
// NULL을 만날 때까지 계속 진행해서 찾으면 된다.
// 
// TreeNode* delete_node(TreeNode* root, int key) 참고
//

//
// delete_node 함수에 있는 min_value_node()는 주어니 이진 탐색 트리에서 최소 키값을 가지는 노드를 찾아 반환한다.
//

TreeNode* min_value_node(TreeNode* node) {
	TreeNode* current = node;

	// 맨 왼쪽 단말 노드를 찾으러 내려감
	while (current->left != NULL)
		current = current->left;

	return current;
}


TreeNode* delete_node(TreeNode* root, int key) {
	if (root = NULL) return root;

	if (key < root->key)
		root->left = delete_node(root->left, key);

	else if (key > root->key)
		root->right = delete_node(root->right, key);

	else {
		if (root->left == NULL) {
			TreeNode* temp = root->right;
			free(root);
			return temp;
		}

		else if (root->right==NULL)
		{
			TreeNode* temp = root->left;
			free(root);
			return temp;
		}


		// 세 번째의 경우
		TreeNode* temp = min_value_node(root->right);

		root->key = temp->key;
		root->right = delete_node(root->right, temp->key);

	}

	return root;
}

// 중위 순회
void inorder(TreeNode* root) {
	if (root) {
		inorder(root->left);
		printf(" [%d] ", root->key);
		inorder(root->right);
	}
}

int main(void) {

	TreeNode* root = NULL;
	TreeNode* tmp = NULL;

	root = insert_node(root, 30);
	root = insert_node(root, 20);
	root = insert_node(root, 10);
	root = insert_node(root, 40);
	root = insert_node(root, 50);
	root = insert_node(root, 60);

	printf("이진 탐색 트리 중위 순회 결과 \n");

	inorder(root);
	printf("\n\n");

	if (search(root, 30) != NULL)
		printf("이진 탐색 트리에서 30을 발견함 \n");
	else
		printf("이진 탐색 트리에서 30을 발견못함 \n");

	return 0;

}