#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

//
// 
// 
//			8.1 트리의 개념
// 
// 만약 자료가 계층적인 구조(hierarchical structure)를 가지고 있다면 어떻게 해야 할까?
// 예를 들어 가족의 가계도, 회사의 조직도, 컴퓨터의 디렉토리 구조 등의 계층적인 자료는 어떻게 표현해야 하는가?
// 이러한 경우에 선형 자료구조는 더 이상 적합하지 않다.
// 
// 
// 트리(tree)는 이러한 계층적인 자료를 표현하는데 적합한 자료이다. 이를 트리라고 부르는 이유는 마치 실제 트리를 거꾸로
// 엎은 듯한 모양을 하고 있기 때문이다.
// 
// 
// 또한 인공지능 문제에서도 트리가 사용된다. 대표적인 것이 결정 트리(decision tree)이다. 결정 트리는 인간의 의사 결정 구조를
// 표현하는 한 가지 방법이다. 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
//			트리의 용어들
// 
// 
// 트리: 한 개 이상의 노드로 이루어진 유한 집합
// 
// 루트(root) 노드: 계층적인 구조에서 가장 놓은 곳에 있는 노드
// 서브 트리(subtree): 루트 노드를 제외한 모든 나머지 노드
// 
// 트리에서 루트와 서브트리는 선으로 연결된다. 이 연결선을 간선(edge)
// 라고 한다.
// 
// 노드들 간에는 부모 관계, 형제 관계, 조상과 자손 관계가 존재한다.
// 
// 조상 노드(ancestor node): 루트 노드에서 임의의 노드까지의 경로를 이루고 있는 노드들을 의미
// 
// 후손 노드(descendent node): 임의의 노드 하위에 연결된 모드 노드들을 의미함.
// 
// 단말 노드(terminal node, leaf node): 자식 노드가 없는 노드를 의미. 이에 반대되는 의미를 가진 노드를 비단말 노드(nonterminal node)라고 한다.
// 
// 
// 
// 
// 노드의 '차수'(degree): 어떤 노드가 가지고 있는 자식 노드의 개수를 의미함.
// 
// 트리의 차수: 트리가 가지고 있는 노드의 차수 중에서 가장 큰 값을 의미.
// 
// 책의 그림 [8-5]를 보면 A와 B의 노드의 차수고 3으로 가장 크므로 전체 트리의 차수가 3이 된다.
// 
// 트리에서의 레벨(level)은 트리의 각 층에 번호를 매기는 것으로서 정의에 의하여 루트의 레벨은 1이 되고 한 층씩 내려갈수록 1씩 증가한다.
// 트리의 높이(height)는 트리가 가지고 있는 최대 레벨을 말한다. 또한 나뭉가 모이는 숲이 되듯이 트리의 집합을 포리스트(forest)라고 한다.
// 
// 
// 
// 
//			트리의 종류
// 
// 트리를 컴퓨터 메모리상에서 표현하는 방법은 여러 가지가 될 수 있다. 일반적으로 각 노드가 데이터를 저장하는 데이터 필드와 자식 노드를 가리키는
// 링크 필드를 가지게 하는 것이다. 일반적인 트리에서 각 노드들은 서로 다른 개수의 자식 노드를 가지므로 노드에 따라서 링크 필드의 개수가 달라진다.
// 
// 
// ---------------------------------------------------------------------------------------------------------------------------------------------
// | 데이터			|		링크1		|		링크 2		|						...									| 링크 n			   |	
// |-------------------------------------------------------------------------------------------------------------------------------------------|
// 
// 
// 하지만 이러한 방법의 문제점은 노드의 크기가 고정되지 않는다는 것이다. 즉 노드에 붙어 있는 자식 노드의 개수에 따라서 노드의 크기가 커지기도 하고
// 작아지기도 한다. 이와 같이 노드의 크기가 일정하지 않으면 프로그램이 복잡하게 된다. 따라서 여기서는 자식노드의 개수가 2개인 이진트리만을 다루기로
// 한다.
// 
// 
// 
// 
// 
// 
// 
//				8.2 이진 트리 소개
// 
//		이진 트리의 정의
// 
// 트리 중에서 가장 많이 쓰이는 트리가 이진트리이다. 모든 노드가 2개의 서브 트리를 가지고 있는 트리를 이진 트리(binary tree)라고 한다. 서브 트리는 
// 공집합일 수도 있다. 따라서 이진트리의 노드에는 최대 2개까지의 자식 노드가 존재할수 있고 모든 노드의 차수가 2 이하가 된다. 공집합도 이진트리라는 점을
// 유의하도록 하자. 
// 
// 또한 이진 트리에는 서브 트리간의 순서가 존재한다. 따라서 왼쪽 서브트리와 오른쪽 서브 트리는 서로 구별된다.
// 
// 
// 이진트리가 순환적으로 정의되고 있는데, 다음과 같이 정의되어진다.
// 
//		정의 8.1 이진트리
// ----------------------------------------------------------------------------------------------------------------------------------------
// 1) 공집합이거나
// 2) 루트와 왼쪽 서브 트리, 오른쪽 서브 트리로 구성된 노드들의 유한 집합으로 정의된다. 이진트리의 서브트리들은 모두 이진트리여야 한다.
// ----------------------------------------------------------------------------------------------------------------------------------------
// 
// 
//		일반트리와 이진 트리의 차이점을 생각해보면 다음과 같다.
// ----------------------------------------------------------------------------------------------------------------------------------------
//	* 이진트리의 모든 노드는 차수가 2이하이다. 즉 자식 노드의 개수가 2 이하이다. 반면 일반 트리는 자식 노드의 개수에 제한이 없다.
//  * 일반 트리와는 달리 이진 트리는 노드를 하나도 갖지 않을 수도 있다.
//	* 서브 트리간에 순서가 존재한다는 것도 다른 점이다. 따라서 왼쪽 서브트리와 오른쪽 서브트리를 구별한다. 
// 
// 
// 
// 
//			이진트리의 성질
// 
// 
// * n개의 노드를 가진 이진트리는 정확하게 n-1의 간선을 가진다. 그 이유는 이진트리에서 노드는 루트를 제외하면 정확하게 하나의 부모노드를 가진다.
// 그리고 부모와 자식 노드 간에는 정확하게 하나의 간선만이 존재한다. 따라서 간선의 개수는 n-1이다.
// 
// 
// * 높이가 h인 이진트리의 경우, 최소 h개의 노드를 가지며 최대 2^h-1개의 노드를 가진다. 그 이유는 한 레벨에는 적어도 하나의 노드는 그 이유는 
//	한 레벨에는 적어도 하나의 노드는 존재해야 하므로 높이가 h인 이진트리는 적어도 h개의 노드를 가진다. 또한 하나의 노드는 최대 2개의 자식을
//	가질 수 있으므로 레벨 i에서의 노드의 최대개수는 2^(i-1)이 된다. 따라서 전체 노드 개수는 sum _{i=1} ^{h} 2 ^{h-1}=(2^h)-1가 된다.
// 
// 
// * n개의 노드를 가지는 이진트리의 높이는 최대 n이거나 최소 [log_2(n+1)]ceil이 된다. 그 이유는 레벨당 하나의 노드는 있어야 하므로 높이가 n을 넘을 수는 없다.
//	 그리고 앞의 성질에서 높이 h의 이진트리가 가질 수 있는 노드의 최대값은 (2^h)-1이다. 따라서 n<=(2^h)-1의 부등식이 성립하여 양변에 log를 취하여 정리하면
//	 h>=log_2(n+1)이 된다. h는 정수여야하므로 h>=[log_2(n+1)]이 된다. [...]ceil은 올림 연산으로 [2.4]은 3이 된다.
// 
// 
//			
//			이진트리의 분류
// 
//	이진트리는 다음과 같이 형태에 따라 분류할 수 있다.
// 
//		* 포화 이진 트리(full binary tree)
//		* 완전 이진 트리(complete binary tree)
//		* 기타 이진 트리
// 
// 
//	포화 이진 트리(full binary tree)는 용어 그대로 트리의 각 레벨에 노드가 꽉 차 있는 이진트리를 의미한다. 즉 높이 k인 포화 이진트리는 정확하게 2^k-1개의 노드를 가진다.
//  일반적으로 포화 이진트리에서의 노드의 개수는 다음과 같이 계산된다.
// 
// 
//				sum _{i=0} ^{k-1} 2 ^{i}=2^h-1
// 
// 포화 이진 트리에는 다음과 같이 각 노드에 번호를 붙일 수 있다. 노드에 번호를 부여하는 방법은 레벨 단위로 왼쪽에서 오른쪽으로 번호를 붙이면 된다. 그리고 이 번호는 항상
// 일정하다.
// 
// 
// 
// '완전 이진 트리(complete binary tree)'는 높이가 k일 때 레벨 1부터 k-1까지는 노드가 모두 채워져 있고 마지막 k레벨에서는 왼쪽부터 오른쪽으로 노드가 순서대로 채워져 있는 
// 이진트리이다. 마지막 레벨에서는 노드가 꽉차있지 않아도 되지만 중간에 빈 곳이 있어서는 안된다. 따라서 포화 이진트리는 항상 완전 이진트리이지만 그 역은 항상 성립하지 않는다.
// 포화 이진트리의 노드 번호와 완전 이진트리의 노드 번호는 1대1로 대응한다. 
// 
// 
// 
// 
//				8.3 이진 트리의 표현
// 
//	이진 트리를 컴퓨터 프로그램 안에서 어떻게 표현할 수 있는지 알아보자. 다음의 2가지 방법이 있다.
// 
//			* 배열을 이용하는 방법
//			* 포인터를 이용하는 방법
// 
//
// 
// 
// 		배열 표현법
// 
// 
// '배열을 이용하는 법'은 주로 '포화 이진 트리'나 '완전 이진 트리'의 경우 많이 쓰이는 방법이나 그 외의 이진트리도 저장이 불가능 한 것은 아니다.
//	이 방법은, 저장하고자 하는 이진 트리를 일단 완전 이진 트리라고 가정하고 이진 트리의 깊이가 k이면 2^k-1개의 공간을 연속적으로 할당한 다음,
//	완전 이진 트리의 번호대로 노드들을 저장한다.
// 
//	예를 들어서 트리들은 번호가 먼저 매겨진 다음, 이 번호에 따라서 배열에 저장된다. 예를 들면, 노드 A는 노드 번호가 1이므로 배열의 인덱스 1에
// 저장되었고 노드 B는 노드 번호가 2이므로 배열의 인덱스 2에 저장되었다. 여기서 인덱스 0은 사용되지 않음을 유의하라. 인덱스 0을 사용하지 않는 
// 편이 계산을 간단하게 만든다. 완전 이진트리가 아닌 일반적인 이진트리인 경우에는 배열 표현법을 사용하면 저장할 수는 있지만, 기억공간의 낭비가
// 심해진다.
// 
// 
// 
// 
// 배열 표현법에서의 부모와 자식의 인덱스의 관계를 살펴보자. 배열 표현법에는 인덱스만 알면 노드의 부모나 자식을 쉽게 알 수 있다. 부모와 자식의
// 인덱스 사이에는 다음과 같은 공식이 성립이 된다.
// 
// (단순히 편의성을 위한 것)
// -------------------------------------------------------------------------------------------------------------------------------------------
//		* 노드 i의 부모 노드 인덱스 = i/2
//		* 노드 i의 왼쪽 자식 노드 인덱스 = 2i
//		* 노드 i의 오른쪽 자식 노드 인덱스 = 2i+1
// -------------------------------------------------------------------------------------------------------------------------------------------
// 
// 
//			링크 표현법
// 
// 링크 표현법에서는 트리에서의 노드가 구조체로 표현되고, 각 노드가 표인터를 가지고 있어서 이 포인터를 이용하여 노드와 노드를 연결하는 방법이다.
// 이진트리를 링크 표현법으로 표현하여보면 하나의 노드에 3개의 필드를 가지는데, 데이터를 저장하는 필드, 왼쪽 자식노드, 오른쪽 자식노드 2개의 포인터
// 필드를 가진다. 이 2개의 포인터를 이용하여 부모노드, 자식노드를 연결한다.
// 
// 
// 
// 이진트리를 링크 표현에 의해 나타내기 위해서는 C언어의 구조체와 포인터 개념을 이용하여야 한다. 먼저 구조체를 이용하여 노드의 구조를 정의하고 링크는
// 포인터의 개념을 이용하여 정의하면 된다. 저장되는 데이터는 정수라고 가정하자.여기서 TreeNode는 트리 노드에 대한 타입이다. 
// 
//

typedef struct TreeNode {
	int data;
	struct TreeNode* left, * right;

}TreeNode;

//
// 링크법으로 표현된 트리는 루트노드를 가리키는 포인터만 있다면 트리안의 모든 노드들에 접근할 수 있다. 이것은 연결 리스트와 아주 유사한데, 연결 리스트도
// 포인터에 의하여 연결되 구조이기 때문이다.
// 
//


int main(void) {
	TreeNode* n1, * n2, * n3;

	n1 = (TreeNode*)malloc(sizeof(TreeNode));
	n2 = (TreeNode*)malloc(sizeof(TreeNode));
	n3 = (TreeNode*)malloc(sizeof(TreeNode));

	n1->data = 10;
	n1->left = n2;
	n1->right = n3;

	n2->data = 20;
	n2->left = NULL;
	n2->right = NULL;

	n3->data = 30;
	n3->left = NULL;
	n3->right = NULL;

	free(n1); free(n2); free(n3);
	return 0;
}