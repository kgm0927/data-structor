#include<stdio.h>
#include<stdlib.h>
#include<memory.h>

//
//		8.4 이진 트리의 순회
// 
// 기본적으로 이진 트리도 데이터를 저장하기 위한 자료 구조이다. 데이터는 노드의 데이터 필드를 이용하여 저장한다.
// 이진 트리를 순회(traversal)한다는 것은 이진트리에 속하는 모든 노드를 한번씩 방문하여 노드가 가지고 있는 데이터를
// 목적에 맞게 처리하는 것을 의미한다.
// 우리가 트리를 사용하는 목적은 트리의 노드에 자료를 저장하고 필요에 따라서 이 자료를 처리하기 위함이다.
// 
// 
// 
//		이진 트리 순회방법
// 
// 
// 이진트리를 순회하는 표준적인 방법에는 전위, 중위, 후위의 3가지 방법이 있다. 이는 루트와 왼쪽 서브트리, 오른쪽 서브트리
// 중에서 루트를 언제 방문하느냐에 따라 구분된다. 
// 
// 만약 루트를 방문하는 작업을 V라고 하고 왼쪽서브트리방문을 L, 오른쪽 서브트리 방문을 R이라고 하면 다음과 같이 3가지 방법을
// 생각할 수 있다.
// 
// 전위순회: 루트를 서브 트리에 앞서서 먼저 방문				: VLR
// 중위순회: 루트를 왼쪽과 오른쪽 서브트리 중간에 방문하면		: LVR
// 후위순회: 루트를 서브트리 방문 후에 방문하면 된다.			: LRV
//
// 
// 
// 트리 순회 알고리즘은 우리가 앞에서 공부하였던 '순환 기법'을 사용한다. 사실 복잡한 이진트리를 순회하여야 할 때 순환을 사용하지
// 않고서는 도저히 순회 알고리즘을 만들 수 없다. 
// 
// 이진트리에서 보면 전체 트리나 서브 트리나 그 구조는 완전히 동일하다. 따라서 전체 트리 순회에 사용된 알고리즘은 똑같이 서브 트리에
// 적용할 수 있는 것이다. 다만 문제의 크기가 작아진다. 따라서 순환에서 공부했듯이 문제의 구조는 같고 크기만 작아지는 경우라면 순환을
// 적용할 수 있다.
// 
// 
// 
//


typedef struct TreeNode {
	int data;
	struct TreeNode* left, * right;
}TreeNode;


TreeNode n7 = { 22,NULL,NULL };
TreeNode n6 = { 95,NULL,NULL };
TreeNode n4 = { 5 ,NULL,NULL };
TreeNode n2 = { 15 ,&n4,NULL };
TreeNode n5 = { 35,&n7,NULL };
TreeNode n3 = { 93,&n5,&n6 };
TreeNode n1 = { 17, &n2,&n3 };

TreeNode* root = &n1;

//
//			중위순회
// 
// 
// 중위순회는 먼저 왼쪽 서브트리, 루트, 오른쪽 서브트리 순으로 방문한다.
// 
//		1. 왼쪽 서브트리를 방문한다.
//		2. 루트노드를 방문한다.
//		3. 오른쪽 서브트리를 방문한다.
// 
// -----------------------------------------------------------------------------------------------------
//	inorder(x):
// 
// 1. if!=NULL
// 2.		then inorder(LEFT(x));
// 3.			 print DATA(x);
// 4.			inorder(RIGHT(x));
// ------------------------------------------------------------------------------------------------------
// 
// 알고리즘 설명
// 
// 1. 노드 x가 NULL이면 더 이산 호출을 하지 않는다.
// 2. x의 왼쪽 서브트리를 순환 호출하여 방문한다.
// 3. x의 데이터를 출력한다.
// 4. x의 오른쪽 서브트리를 순환 호출하여 방문한다.
// 
// 
// 
//

// 중위 순회
void inorder(TreeNode* root) {
	if (root != NULL)
	{
		inorder(root->left);		// 왼쪽서브트리 순회
		printf("[%d] ", root->data);// 노드 방문
		inorder(root->right);		// 오른쪽서브트리 순회
	}
}




//		
//		전위 순회
// 
// 전위 순회는 루트를 먼저 방문하고 그 다음에 왼쪽 서브트리를 방문하고 오른쪽 서브트리를 마지막으로 방문하는 것이다.
// 
//		1. 루트 노드를 방문한다.
//		2. 왼쪽 서브트리를 방문한다.
//		3. 오른쪽 서브트리를 방문한다.
// 
// 전위 순회 알고리즘을 유사 코드로 표현하면 이러하다.
//
// ----------------------------------------------------------------------------------------------------------------- 
//	preorder(x):
// 
// 1. if x!=NULL
// 2.		then print DATA(x);
// 3.			 preorder(LEFT(x));
// 4.			 preorder(RIGHT(x));
// -----------------------------------------------------------------------------------------------------------------
// 
// 알고리즘 설명
// -----------------------------------------------------------------------------------------------------------------
// 1. 노드 x가 NULL이면 더 이상 순환호출을 하지 않는다.
// 2. x의 데이터를 출력한다.
// 3. x의 왼쪽 서브트리를 순환호출하여 방문한다.
// 4. x의 오른쪽 서브트리를 순환호출하여 방문한다.
// -----------------------------------------------------------------------------------------------------------------
// 
// 
// 전위 순회에서 루트노드의 방문을 마쳤다고 가정하자. 
// 
// 그러면 왼쪽 서브트리도 하나의 이진트리이다. 따라서 전체트리와 똑같은 방식으로 서브트리를 방문하면 된다. 즉 왼쪽 서브트리의
// 루트를 먼저 방문하고 왼쪽 서브트리의 왼쪽 서브트리를 그 다음에, 마지막으로 왼쪽 서브트리의 오른쪽 서브트리를 방문하면 된다.
// 즉 모든 서브트리에 대하여 같은 알고리즘을 반복한다.
// 
// 
// 

// 전위 순회
void preorder(TreeNode* root) {
	if (root != NULL) {
		printf("[%d] ", root->data);
		preorder(root->left);
		preorder(root->right);
	}
}


//
//			후위 순회
// 
// 후위 순회는 왼쪽 서브트리, 오른쪽 서브트리, 루트 순으로 방문한다. 다음은 후위순회를 정리한 것이다.
// 
// 
// 1) 왼쪽 서브트리의 모든 노드를 방문한다.
// 2) 오른쪽 서브트리의 모든 노드를 방문한다.
// 3) 루트노드를 방문한다.
// 
//	트리 후위 순회 알고리즘
// ----------------------------------------------------------------------------------------------------------------------
//		postorder(x):
// 1.		if!=NULL
// 2.			then postorder(LEFT(x));
// 3.				 postorder(RIGHT(x));
// 4.				 print DATA(x);
// -----------------------------------------------------------------------------------------------------------------------
// 
// 
// 알고리즘 설명
// -----------------------------------------------------------------------------------------------------------------------
// 1. 노드 x가 NULL이면 더 이산 순환호출을 하지 않는다.
// 2. x의 왼쪽 서브트리를 순환호출하여 방문한다.
// 3. x의 오른쪽 서브트리를 순환호출하여 방문한다.
// 4. x의 데이터를 출력한다.
// -----------------------------------------------------------------------------------------------------------------------
//

void postorder(TreeNode* root) {
	if (root != NULL)
	{
		postorder(root->left);
		postorder(root->right);
		printf("[%d] ", root->data);

	}
}

//
// 
//				전위, 중위, 후위 순회 구현
// 
// 3가지의 표준적인 순회 방법을 C언어 함수로 구현하여 보자. 함수의 매개변수는 루트를 가리키는 포인터가 된다. 먼저 표준적인
// 순회방법이 순환적으로 정의되어 있다는 것에 착안하여야 한다. 왼쪽이나 오른쪽 서브트리를 방문하는 것은, 전체 트리를 방문하는
// 거나 다를 바가 없다. 즉 전체 트리를 방문 함수를 다시 한번 호출해주면 되는 것이다. 다만 다른 점은 함수의 매개변수가 달라지게
// 된다. 즉 서브트리를 방문하는 경우에는 서브트리의 루트 노드 포인터를 함수의 매개변수로 전달하면 된다.
// 
// 
//

int main(void) {
	printf("중위 순회=");
	inorder(root); printf("\n");


	printf("전위 순회=");
	preorder(root); printf("\n");


	printf("후위 순위=");
	postorder(root); printf("\n");

	return 0;
}