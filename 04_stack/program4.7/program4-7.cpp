#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_STACK_SIZE 100

typedef char element;


typedef struct {
	element data[MAX_STACK_SIZE];
	int top;
}StackType;

void init_stack(StackType* s) {
	s->top = -1;
}

int is_empty(StackType* s) {
	return(s->top == -1);
}

int is_full(StackType* s) {
	return (s->top == (MAX_STACK_SIZE - 1));
}

void push(StackType* s, element item) {
	if (is_full(s))
	{
		fprintf(stderr, "스택 포화 에러\n");
		return;
	}
	else s->data[++(s->top)] = item;
}

element pop(StackType* s) {
	if (is_empty(s))
	{
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[(s->top)--];
}

element peek(StackType* s) {
	if (is_empty(s)) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[s->top];
}
int eval(const char exp[]) {
	int op1, op2, value, i = 0;
	int len = strlen(exp);
	char ch;
	StackType s;

	init_stack(&s);

	for ( i = 0; i < len; i++)
	{
		ch = exp[i];

		if (ch != '+' && ch != '-' && ch != '*' && ch != '/') {//ch가 피연산자라면
			value = ch - '0';
			push(&s, value);
		}
		else {// ch가 연산자라면
			op2 = pop(&s);
			op1 = pop(&s);
			switch (ch)
			{
			
			case '+':push(&s, op1 + op2); break;
			case '-':push(&s, op1 - op2); break;
			case '*':push(&s, op1 * op2); break;
			case '/':push(&s, op1 / op2); break;
			}
		}

	}
	return pop(&s);
}

int main(void) {
	int result;
	printf("후위 표기식은 82/3-32*+ \n");
	result = eval("82/3-32*+");
	printf("결과값은 %d\n", result);
	return 0;
}

//
//			4.5 스택의 응용 : 후위 표기 수직의 계산 (p. 124)
// 
// 
//		y=a*(b-c)+d/c
// 
// 연산자들은 우선 순위가 있어서 우선순위가 높은 연산자가 먼저 계산된다. 컴파일러는 어떤 도구를 사용하여
// 수식을 계산하는 것일까? 수식은 스택을 사용하여 계산된다.
// 
// 수식을 표기하는 방법에는 중위(inflix), 후위(postfix), 전위(prefix)의 3가지 방법이 있다. 연산자가 피연산자 사이에 있으면, 중위이고
// 연산자가 피연산자 뒤에 있다면 후위이다. 연산자가 피연산자 앞에 있으면 전위하고 한다. 인간은 주로 중위표기법을 사용하지만 컴파일러는
// 주로 후위표기법을 사용한다. 프로그래머가 수식을 중위표기법으로 작성하면 컴파일러는 이것을 후위표기법으로 변환한 후에 스택을 이용하여
// 계산한다.
// 
// 
//	<표 4-1> 수식의 3가지 표기법
// 
// ---------------------------------------------------------------------------------------------------------------------------------------
//		중위 표기법			|								전위 표기법						|			후위 표기법
// ---------------------------------------------------------------------------------------------------------------------------------------
//		2+3*4				|				+*ab5											|			ab*5+
// ---------------------------------------------------------------------------------------------------------------------------------------
//		(1+2)*7				|				*+127											| 12+7+
// ---------------------------------------------------------------------------------------------------------------------------------------
// 
// 
// 컴파일러에서 후위 표기 방법을 선호하는 이유는 중위표기법 처럼 괄호가 필요없기 때문이다. 또 연산자의 우선순위도 생각할 필요도 없이 이미 식 자체에
// 우선순위가 포함되어 있기 때문이다.
// 
// 
// 
//			알고리즘 4.6 후위 표기 수식 계산 알고리즘
// 
//
// 
//		calc_postfix:
//				스택 s를 생성하고 초기화한다.
//				for item in 후위표기식 do
//					if (item이 피연산자라면)
//						push(s,item)
// 
//					else if( item이 연산자 op라면)
//						second<-pop(s)
//						first<-pop(s)
//						result<-first op second			// op는 +-*/중의 하나
//						push(s,result)
//				
//				final_result<-pop(s);
// 
// 
// 
// 
// 
// 
//				중위표기수식을 후위표기수식으로 변환
// 
// 
// 앞에서 스택을 이용하여 후위 표기 수식을 계산하는 프로그램을 살펴보았다. 하지만 프로그래머가 입력하는 수식의 형태는 중위 표기법이다.
// 
// 
// <표 4-2> 중위 표기법과 후위 표기법의 비교
// 
// ----------------------------------------------------------------------------------------------------------------------------------
//							중위 표기법							|						후위 표기법
// ----------------------------------------------------------------------------------------------------------------------------------
//						a+b										|							ab+
// ----------------------------------------------------------------------------------------------------------------------------------
//						(a+b)*c									|							ab+c*
// ----------------------------------------------------------------------------------------------------------------------------------
//					a+b*c										|							abc*+
// ----------------------------------------------------------------------------------------------------------------------------------
// 
// 
// 
// 
// 중위 표기 수식을 후위 표기 수식으로 변환하기 위해 입력 수식을 왼쪽에서 오른쪽으로 스캔한다. 만약 피연산자가 만나게 되면 바로 후위 표기 수식에
// 출력한다. 연산자를 만나게 되면 어딘가에 잠시 저장한다. 왜냐하면 후위 표기 수식에서는 기본적으로 피연산자들 뒤에 연산자가 나오기 때문이다.
// 따라서 적절한 위치를 찾을 때까지 출력을 보류하여야 한다.
// 
// 
// 문제는 + 연산자와 * 연산자 중에서 어떤 것이 먼저 출력되어야 할까? 기본적으로 가장 나중에 스캔된 연산자가 가장 먼저 출력되어야 한다. 따라서 연산자들은
// 스택에 저장되는 것이 타당하다. 왜냐하면 스택은 가장 늦게 입력된 것이 가장 먼저 출력되는 구조이기 때문이다. 따라서 스택에 존재하는 연산자가 현재 처리중인
// 연산자보다 우선순위가 높으면 일단 스택에 있는 연산자들 중에서 우선순위가 높은 연산자들을 먼저 출력한 다음 처리중인 연산자를 스택에 넣어야 한다. 만약
// 우선순위가 같으면 어떻게 되겠는가?
// 
// 예를 들어 a-b+c 같은 경우에 만약 abc+-로 출력한다면 문제가 발생한다. 따라서 우선순위가 같은 경우에도 일단 스택 상단 요소를 꺼내어 출력하여야 한다.
// 
// 
// 
// 괄호는 어떻게 처리해야 하는가? 왼쪽 괄호는 무조건 스택에 삽입한다. 왼쪽괄호가 일단 스택에 삽입되면 우리는 왼쪽괄호를 제일 우선순위가 낮은 연산자로 취급한다.
// 즉 다음에 만나는 어떤 연산자로 스택에 삽입된다.
// 
// 
// 
// 
// 
// 
// 
// 이때까지 설명했던 알고리즘을 의사 코드로 만들어 보면 다음과 같다.
// 
// 
//		알고리즘 4.7: 중위 표기 수식을 후위 표기 수식으로 변환하는 알고리즘
// 
// 
//		infix_to_postfix(exp):
// 
//		스택 s를 생성하고 초기화
//		while(exp에 처리할 문자가 남아 있으면)
//			ch<- 다음에 처리할 문자
//
// 			switch(ch)
//			case 연산자:
//				while(peek(s)의 우선순위 >= ch의 우선순위)
//					e<-pop(s)
//					e를 출력
//				push(s,ch);
//				break;
//
// 			case 왼쪽 괄호:
//				push(s,ch);
//				break;
// 
//			case 오른쪽 괄호:
//				e<-pop(s);
//				while(e!= 왼쪽괄호) do
//					e를 출력
//					e<- pop(s)
//			break;
// 
//			case 피연산자:
//				ch를 출력
//				break;
//		while(not is_empty(s)) do
//			e<-pop(s)
//		e를 출력
// 
// 
// 
// 
// 
// 
//

