#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAZE_SIZE 6
#define MAX_STACK_SIZE 100


typedef struct {
	short r;
	short c;
}element;

typedef struct {
	element data[MAX_STACK_SIZE];
	int top;
}StackType;

element here = { 1,0 }, entry = { 1,0 };


char maze[MAZE_SIZE][MAZE_SIZE] = {
	{'1','1','1','1','1','1'},
	{'e','0','1','0','0','1'},
	{'1','0','0','0','1','1'},
	{'1','0','1','0','1','1'},
	{'1','0','1','0','0','x'},
	{'1','1','1','1','1','1'},
};


void init_stack(StackType* s) {
	s->top = -1;
}

int is_empty(StackType* s) {
	return(s->top == -1);
}

int is_full(StackType* s) {
	return (s->top == (MAX_STACK_SIZE - 1));
}

void push(StackType* s, element item) {
	if (is_full(s))
	{
		fprintf(stderr, "스택 포화 에러\n");
		return;
	}
	else s->data[++(s->top)] = item;
}

element pop(StackType* s) {
	if (is_empty(s))
	{
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[(s->top)--];
}

element peek(StackType* s) {
	if (is_empty(s)) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[s->top];
}


void push_loc(StackType* s, int r, int c) {
	if (r < 0 || c < 0)return;
	
	if (maze[r][c] != '1' && maze[r][c] != '.') {
		element tmp;
		tmp.r = r;
		tmp.c = c;
		push(s, tmp);
	}
}

void maze_print(char maze[MAZE_SIZE][MAZE_SIZE]) {
	printf("\n");
	for (int r = 0; r < MAZE_SIZE; r++)
	{
		for (int c = 0; c < MAZE_SIZE; c++) {
			printf("%c", maze[r][c]);
	}
		printf("\n");
	}
}

int main(void) {
	int r, c;
	StackType s;

	init_stack(&s);
	here = entry;
	while (maze[here.r][here.c]!='x')
	{
		r = here.r;
		c = here.c;

		maze[r][c] = '.';

		maze_print(maze);

		push_loc(&s, r + 1,c);
		push_loc(&s,r-1 , c);
		push_loc(&s, r, c - 1);
		push_loc(&s, r, c + 1);

		if (is_empty(&s))
		{
			printf("실패\n"); 
			return 0;
		}
		else
			here = pop(&s);

	}
	printf("성공\n");
	return 0;
}

//
//				4.6 스택의 응용: 미로 문제
// 
// 
// 미로 문제(maze solving problem)이란 아래의 그림과 같이 미로에 같힌 생쥐가 출구를 찾는 문제이다.
// 
// 
// 
// 
// 
// 미로에서 탈출하기 위해서는 생쥐는 미로를 체계적으로 탐색하여야 한다. 생쥐가 출구를 찾는 기본적인 방법은 시행착오 방법으로서
// 하나의 경로를 선택하여 한번 시도해보고 안되면 다시 다른 방법을 시도하는 것이다. 문제는 현재의 경로가 안 될 경우에 다른 경로를 선택해야 
// 한다는 것으로 다른 경로들이 어딘가에 저장되어 있어야 한다.
// 
// 따라서 가능한 경로들이 저장되는데 그 중에서 가장 최근에 저장한 경로가 쉽게 추출되는 자료구조를 사용해야 할 것이다. 따라서 스택이 자연스럽게
// 후보 자료 구조가 된다. 구체적으로 현재 위치에거 갈 수 있는 방들의 좌표를 스택에 기억하였다가 막다른 길을 만나면 아직 가보지 않은 방 중에서
// 가장 가까운 방으로 다시 돌아가서 새로운 경로를 찾는 것이다. 또한 한번 지나간 방을 다시 지가나면 안될 것이다.
// 
// 
// 미로 문제를 위하여 하나의 스택을 가정하자. 생쥐는 현재 위치에서 이동이 가능한 칸들의 위치를 위, 아래, 왼쪽, 오른쪽의 순서로 스택에 저장하고
// 스택에서 맨 위의 위치를 꺼내어 현재의 위치로 한 다음에, 같은 작업을 반복한다.
// 
// 
// 미로탐색 알고리즘을 간단한 미로를 이용하여 설명하여 보자. 모든 위치는 (행,열)로 표시하기로 한다. 현재 스택에는 아무것도 없다. 생쥐는 현재 위치에서
// 위쪽과 아래쪽, 왼쪽과 오른쪽을 살펴본다.만약 이들 우치가 아직 방문되지 않았고 갈 수 있는 위치면 그 위치들을 스택에 삽입한다. 현재 위치인(1,0)에서 갈 수
// 있는 위치는 오른쪽 방향 뿐인(1,1) 뿐이다. 따라서 (1,1)은 아직 방문하지 않은 위치이므로 스택에 삽입된다.
// 
// 여기서 (1,0)으로도 갈 수 있지만 (1,0)은 이미 방문한 것으로 표시되어 있기 때문에 스택에 삽입되지 않는다. 다음 단계는 스택에서 하나의 위치를 꺼내어 그 위치를
// 현재 위치로 만들고 (1,1)에서 갈 수 있는 위치들을 탐색한다. (1,1)에서는 (2,1)과 (1,2)로 갈 수 있다. 이 위치들을 모두 스택에 저장한다. 다음에도 마찬가지로
// 스택에서 맨 위에 있는 위치인(1,2)를 꺼내어 현재 위치로 만들고 목표 위치에 도달했는지 검사한 다음, 목표 위치가 아니면 이동이 가능한 위치들 중에서 가능한 위치들을
// 스택에 저장한다. 이미 방문한 위치는 표시가 되어 있으므로 다시 스택에 들어가지 않는다. 이상과 같은 알고리즘을 목표 위치에 도달할 때까지 되풀이 하게 되면 결국 출구를
// 찾을 수 있다. 
// 
// 
// 
// 
// 
//			알고리즘 4.8 미로 탐색 프로그램
// 
// 
//		maze_search():
//			
// 
//			스택 s과 출구의 위치 x, 현재 생쥐의 위치를 초기화
//			while(현재 위치가 출구 아니면)	do
//				현재위치를 방문한 것으로 표기
//				
//				if(현재위치의 위, 아래, 왼쪽, 오른쪽 위치가 아직 방문되지 않았고 갚수 있으면)
//					then 그 위치들을 스택에 push
//				if(is_empty(s))
//					then 실패
//				else 스택에서 하나의 위치를 꺼내어 현재 위치로 만든다;
//			성공;
// 
// 
// 
// 이제 미로 탐색 알고리즘을 C언어로 구현해본다. 여기서는 2차원 문자 배열 maze[][]를 이용하여
// 미로를 표현하고자 한다. 배열의 값이 0이면 갈 수 있는 길이고, 1이면 지나갈 수 없는 벽을 의미한다.
// 출구는 x로 표시되고 현재 생쥐의 위치는 m으로 표시된다.
// 
// 
// 문제는 간단하게 하기 위해서 미로는 2차원 배열로 프로그램에 미리 입력되어 있다고
// 가정한다. 생쥐의 위치는 (행, 열)의 좌표값으로 표시한다. 따라서 스택에 저장되는 데이터는(행, 열) 좌표가 되어야 한다.
// 따라서 (행, 열) 좌표를 저장할 수 있는 구조체를 만들면 된다.
// 
// 이제 C언어를 이용하여 구현하여 보자. 먼저 프로그램 4.9의 소스에서 방문이 끝난 위치는 maze[][] 배열의 값을 '.'으로 바꾸어
// 다른 위치들과 구별함을 유의하라. 만약 스택이 비었는데도 출구를 찾지 못했다면 미로 탐색은 실패했음을 출력하고 프로그램을 끝낸다.
// 만약 동일한 좌표가 중복해서 스택에 저장되어도 문제는 발생하지 않는다.
// 
// 어떤 위치가 방문이 되면 그 주위의 위치들이 모두 방문된 것으로 표시가 되므로 다음에 동일한 위치가 스택에서 꺼내지더라도 다시 방문하지는
// 않는다.
// 
// 
//
//